# -*- coding: utf-8 -*-
"""high pass and low pass filtering.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yBzzaEJRTPHaAZQnHrNdlAWjnC3IRY21
"""

pip install opencv-python numpy

import cv2
import numpy as np
import sys
# === COLAB FIX: Import the display patch ===
from google.colab.patches import cv2_imshow

# Define the block size (matches #define BLOCK 60)
BLOCK = 60

def main():
    # --- 1. Setup and Image Load ---
    image_file = input("Please enter the path to your image: ")
    print(f"Processing {image_file}")

    frame = cv2.imread(image_file, cv2.IMREAD_GRAYSCALE)

    if frame is None:
        print(f"Error: could not read image '{image_file}'", file=sys.stderr)
        print("Please check the path and try again.", file=sys.stderr)
        return 1

    rows, cols = frame.shape
    cy, cx = rows // 2, cols // 2
    f_image = frame.astype(np.float32)

    # --- 3. FFT ---
    print("Direct transform...")
    fourier_transform = np.fft.fft2(f_image)
    fourier_shift = np.fft.fftshift(fourier_transform)

    # --- 5. Block the low frequencies (High-Pass Filter) ---
    fourier_shift[cy - BLOCK : cy + BLOCK, cx - BLOCK : cx + BLOCK] = 0

    # --- 6. Shuffle Quadrants Back ---
    f_ishift = np.fft.ifftshift(fourier_shift)

    # --- 7. Inverse FFT ---
    print("Inverse transform...")
    inv_fft = np.fft.ifft2(f_ishift)
    img_filtered = np.abs(inv_fft)

    # --- 8. Post-Processing and Metric Calculation ---
    min_val, max_val, _, _ = cv2.minMaxLoc(img_filtered)
    if max_val <= 0.0:
        print("No information, complete black image!", file=sys.stderr)
        return 1

    log_img = np.log(img_filtered + 1e-9)
    log_img *= 20

    # Calculate the mean
    result = np.mean(log_img)
    print(f"Result : {result}")

    # --- 9. Show if you like (Using cv2_imshow for Colab) ---
    final_image = cv2.normalize(log_img, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Note: cv2_imshow does not need cv2.waitKey(0)
    print("\n--- Input Image (Grayscale) ---")
    cv2_imshow(frame)
    print("\n--- Result Image (High-Pass Filter Log-Scaled) ---")
    cv2_imshow(final_image)

    # We remove cv2.waitKey(0) and cv2.destroyAllWindows() as they are not needed here.

    return 0

if __name__ == "__main__":
    sys.exit(main())

import cv2
import numpy as np
import sys
from google.colab.patches import cv2_imshow

# Define the block size. This now determines the size of the frequencies KEPT (blur amount).
# A larger BLOCK value means less blurring, a smaller value means more blurring.
BLOCK = 60

def main():
    # --- 1. Setup and Image Load ---
    image_file = input("Please enter the path to your image: ")
    print(f"Processing {image_file}")

    frame = cv2.imread(image_file, cv2.IMREAD_GRAYSCALE)

    if frame is None:
        print(f"Error: could not read image '{image_file}'", file=sys.stderr)
        return 1

    rows, cols = frame.shape
    cy, cx = rows // 2, cols // 2
    f_image = frame.astype(np.float32)

    # --- 2. FFT and Shifting ---
    print("Direct transform...")
    fourier_transform = np.fft.fft2(f_image)
    fourier_shift = np.fft.fftshift(fourier_transform)

    # ----------------------------------------------------
    # --- 3. APPLY LOW-PASS FILTER (The ONLY major change) ---
    # ----------------------------------------------------

    # 1. Create a mask of zeros (same size as FFT)
    mask = np.zeros((rows, cols), np.uint8)

    # 2. Set the central region (low frequencies) to ones
    # This region defines the frequencies we want to KEEP.
    mask[cy - BLOCK : cy + BLOCK, cx - BLOCK : cx + BLOCK] = 1

    # 3. Apply the mask: only the central low frequencies remain.
    # The high frequencies (outside the block) are multiplied by zero and removed.
    fourier_shift_filtered = fourier_shift * mask

    # --- 4. Inverse Shifting ---
    f_ishift = np.fft.ifftshift(fourier_shift_filtered)

    # --- 5. Inverse FFT ---
    print("Inverse transform...")
    inv_fft = np.fft.ifft2(f_ishift)

    # Take the magnitude (real part of the complex number)
    img_filtered = np.abs(inv_fft)

    # --- 6. Post-Processing and Display ---

    # Normalize the filtered image to 0-255 for display
    final_image = cv2.normalize(img_filtered, None, 0, 255, cv2.NORM_MINMAX, dtype=cv2.CV_8U)

    # Display the results
    print("\n--- Input Image (Grayscale) ---")
    cv2_imshow(frame)
    print("\n--- Result Image (Low-Pass Filtered/Blurred) ---")
    cv2_imshow(final_image)

    # Note: We skip the log-scaling and mean calculation as they were specific
    # to the High-Pass metric, but they could be adapted if a blur metric is needed.

    return 0

if __name__ == "__main__":
    sys.exit(main())